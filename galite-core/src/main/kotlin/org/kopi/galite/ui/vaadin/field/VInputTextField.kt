/*
 * Copyright (c) 2013-2020 kopiLeft Services SARL, Tunis TN
 * Copyright (c) 1990-2020 kopiRight Managed Solutions GmbH, Wien AT
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package org.kopi.galite.ui.vaadin.field

import com.vaadin.flow.component.Key
import com.vaadin.flow.component.KeyPressEvent
import com.vaadin.flow.component.ShortcutEvent
import com.vaadin.flow.component.Shortcuts
import com.vaadin.flow.component.textfield.Autocomplete
import com.vaadin.flow.component.textfield.TextField
import com.vaadin.flow.dom.Element

import org.kopi.galite.ui.vaadin.base.Styles

class VInputTextField : TextField() {

  var hasAutocomplete = false
  private var valueBeforeEdit = ""
  private var align: String? = null
  var validationStrategy: TextValidationStrategy? = null

  /**
   * Protected constructor to use to create other types of fields.
   * @param node The node element.
   */
  init {
    className = Styles.TEXT_INPUT
    this.addKeyPressListener { event: KeyPressEvent? -> onKeyPress(event) }
    Shortcuts.addShortcutListener(this,
                                  { keyPasteEvent: ShortcutEvent? -> onBrowserEvent(keyPasteEvent) },
                                  Key.PASTE)
            .listenOn(this)

    Shortcuts.addShortcutListener(this,
                                  { keyContextMenuEvent: ShortcutEvent? -> onBrowserEvent(keyContextMenuEvent) },
                                  Key.CONTEXT_MENU)
            .listenOn(this)

    if (hasAutocomplete) {
      this.autocomplete = Autocomplete.ON
    } else {
      this.autocomplete = Autocomplete.OFF
    }
  }

  fun onKeyPress(event: KeyPressEvent?) {
    TODO()
  }

  fun onBrowserEvent(event: ShortcutEvent?) {
    TODO()
  }

  /**
   * Sets the record number from the display line
   */
  protected fun setRecord() {
    TODO()
  }

  fun setText(text: String?) {
    // set record to synchronize view and model even field is not focused
    var text = text
    setRecord()
    // set only valid inputs
    if (validationStrategy is NoeditValidationStrategy
            || validationStrategy!!.validate(text, maxLength)) {
      if (text == null) {
        text = "" // avoid NullPointerException
      }
      if (text != this.value) {

      }
      value = text
    }
    if (text != null) {
      valueBeforeEdit = text
    }
  }

  /**
   * Sets the input text foreground and background colors.
   * @param foreground The foreground color.
   * @param background The background color.
   */
  fun setColor(foreground: String?, background: String?) {

    // clear server color styles if necessary
    if ((foreground == null || foreground.isEmpty)
            && (background == null || background.isEmpty)) {
      clearServerStyles()
    }
    var style: String = "text-align : " + this.align + ";"
    if (foreground != null && foreground.isNotEmpty()) {
      // set color directly on element style
      style += "color : $foreground !important;"
    }
    if (background != null && background.isNotEmpty()) {
      // set color directly on element style
      style += "background-color : $background !important;"
    }
    element.setAttribute("style", style)
  }

  /**
   * Removes the color styles generated by the server
   */
  protected fun clearServerStyles() {
    TODO()
  }

  /**
   * Sets the fields width.
   * @param width The field width.
   */
  fun setWidth(width: Int) {
    setWidth(width.toString() + "ex")
  }

  /**
   * Returns the field max length.
   * @return The field max length.
   */
  override fun getMaxLength(): Int {
    return this.maxLength
  }

  /**
   * Sets the text zone max length.
   * @param maxLength The max length.
   */
  override fun setMaxLength(maxLength: Int) {
    updateMaxLength(maxLength)
  }

  /**
   * This method is responsible for updating the DOM or otherwise ensuring
   * that the given max length is enforced. Called when the max length for the
   * field has changed.
   *
   * @param maxLength The new max length
   */
  protected fun updateMaxLength(maxLength: Int) {
    if (maxLength >= 0) {
      this.maxLength = maxLength
    } else {
      element.removeAttribute("maxLength")
    }
    setMaxLengthToElement(maxLength)
  }

  /**
   * Sets the max length to the input element.
   * @param newMaxLength The new max length.
   */
  protected fun setMaxLengthToElement(newMaxLength: Int) {
    if (newMaxLength >= 0) {
      element.setAttribute("maxLength", newMaxLength.toString())
    } else {
      element.removeAttribute("maxLength")
    }
  }

  /**
   * Updates the field content.
   * @param text The new text field content.
   */
  fun updateFieldContent(text: String?) {
    this.value = text
  }


  fun autoCompelete(name : String) {
    this.apply {
      element.setAttribute("name", name)
      element.appendChild(Element("input").setAttribute("slot", "input"))

    }
  }
}
